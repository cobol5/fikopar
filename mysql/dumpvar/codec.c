
typedef enum {
	_VARCHAR = 0,
	_DECIMAL = 1,
	_INTEGER = 2
	
} DATATYPE;

struct COLUMN {
	char * columnname;
	DATATYPE type;
	unsigned int length;
	unsigned int scale;
	BOOL isKey;
	struct COLUMN * next;
};

char cp857ToUtf8[] = {
	0x02,0x80,0xc3,0x87,
	0x02,0x81,0xc3,0xbc,
	0x02,0x82,0xc3,0xa9,
	0x02,0x83,0xc3,0xa2,
	0x02,0x84,0xc3,0xa4,
	0x02,0x85,0xc3,0xa0,
	0x02,0x86,0xc3,0xa5,
	0x02,0x87,0xc3,0xa7,
	0x02,0x88,0xc3,0xaa,
	0x02,0x89,0xc3,0xab,
	0x02,0x8a,0xc3,0xa8,
	0x02,0x8b,0xc3,0xaf,
	0x02,0x8c,0xc3,0xae,
	0x02,0x8d,0xc4,0xb1,
	0x02,0x8e,0xc3,0x84,
	0x02,0x8f,0xc3,0x85,
	0x02,0x90,0xc3,0x89,
	0x02,0x91,0xc3,0xa6,
	0x02,0x92,0xc3,0x86,
	0x02,0x93,0xc3,0xb4,
	0x02,0x94,0xc3,0xb6,
	0x02,0x95,0xc3,0xb2,
	0x02,0x96,0xc3,0xbb,
	0x02,0x97,0xc3,0xb9,
	0x02,0x98,0xc4,0xb0,
	0x02,0x99,0xc3,0x96,
	0x02,0x9a,0xc3,0x9c,
	0x02,0x9b,0xc3,0xb8,
	0x02,0x9c,0xc2,0xa3,
	0x02,0x9d,0xc3,0x98,
	0x02,0x9e,0xc5,0x9e,
	0x02,0x9f,0xc5,0x9f,
	0x02,0xa0,0xc3,0xa1,
	0x02,0xa1,0xc3,0xad,
	0x02,0xa2,0xc3,0xb3,
	0x02,0xa3,0xc3,0xba,
	0x02,0xa4,0xc3,0xb1,
	0x02,0xa5,0xc3,0x91,
	0x02,0xa6,0xc4,0x9e,
	0x02,0xa7,0xc4,0x9f,
	0x02,0xa8,0xc2,0xbf,
	0x02,0xa9,0xc2,0xae,
	0x02,0xaa,0xc2,0xac,
	0x02,0xab,0xc2,0xbd,
	0x02,0xac,0xc2,0xbc,
	0x02,0xad,0xc2,0xa1,
	0x02,0xae,0xc2,0xab,
	0x02,0xaf,0xc2,0xbb,
	0x03,0xb0,0xe2,0x96,0x91,
	0x03,0xb1,0xe2,0x96,0x92,
	0x03,0xb2,0xe2,0x96,0x93,
	0x03,0xb3,0xe2,0x94,0x82,
	0x03,0xb4,0xe2,0x94,0xa4,
	0x02,0xb5,0xc3,0x81,
	0x02,0xb6,0xc3,0x82,
	0x02,0xb7,0xc3,0x80,
	0x02,0xb8,0xc2,0xa9,
	0x03,0xb9,0xe2,0x95,0xa3,
	0x03,0xba,0xe2,0x95,0x91,
	0x03,0xbb,0xe2,0x95,0x97,
	0x03,0xbc,0xe2,0x95,0x9d,
	0x02,0xbd,0xc2,0xa2,
	0x02,0xbe,0xc2,0xa5,
	0x03,0xbf,0xe2,0x94,0x90,
	0x03,0xc0,0xe2,0x94,0x94,
	0x03,0xc1,0xe2,0x94,0xb4,
	0x03,0xc2,0xe2,0x94,0xac,
	0x03,0xc3,0xe2,0x94,0x9c,
	0x03,0xc4,0xe2,0x94,0x80,
	0x03,0xc5,0xe2,0x94,0xbc,
	0x02,0xc6,0xc3,0xa3,
	0x02,0xc7,0xc3,0x83,
	0x03,0xc8,0xe2,0x95,0x9a,
	0x03,0xc9,0xe2,0x95,0x94,
	0x03,0xca,0xe2,0x95,0xa9,
	0x03,0xcb,0xe2,0x95,0xa6,
	0x03,0xcc,0xe2,0x95,0xa0,
	0x03,0xcd,0xe2,0x95,0x90,
	0x03,0xce,0xe2,0x95,0xac,
	0x02,0xcf,0xc2,0xa4,
	0x02,0xd0,0xc2,0xba,
	0x02,0xd1,0xc2,0xaa,
	0x02,0xd2,0xc3,0x8a,
	0x02,0xd3,0xc3,0x8b,
	0x02,0xd4,0xc3,0x88,
	0x02,0xd6,0xc3,0x8d,
	0x02,0xd7,0xc3,0x8e,
	0x02,0xd8,0xc3,0x8f,
	0x03,0xd9,0xe2,0x94,0x98,
	0x03,0xda,0xe2,0x94,0x8c,
	0x03,0xdb,0xe2,0x96,0x88,
	0x03,0xdc,0xe2,0x96,0x84,
	0x02,0xdd,0xc2,0xa6,
	0x02,0xde,0xc3,0x8c,
	0x03,0xdf,0xe2,0x96,0x80,
	0x02,0xe0,0xc3,0x93,
	0x02,0xe1,0xc3,0x9f,
	0x02,0xe2,0xc3,0x94,
	0x02,0xe3,0xc3,0x92,
	0x02,0xe4,0xc3,0xb5,
	0x02,0xe5,0xc3,0x95,
	0x02,0xe6,0xc2,0xb5,
	0x02,0xe8,0xc3,0x97,
	0x02,0xe9,0xc3,0x9a,
	0x02,0xea,0xc3,0x9b,
	0x02,0xeb,0xc3,0x99,
	0x02,0xec,0xc3,0xac,
	0x02,0xed,0xc3,0xbf,
	0x02,0xee,0xc2,0xaf,
	0x02,0xef,0xc2,0xb4,
	0x02,0xf0,0xc2,0xad,
	0x02,0xf1,0xc2,0xb1,
	0x02,0xf3,0xc2,0xbe,
	0x02,0xf4,0xc2,0xb6,
	0x02,0xf5,0xc2,0xa7,
	0x02,0xf6,0xc3,0xb7,
	0x02,0xf7,0xc2,0xb8,
	0x02,0xf8,0xc2,0xb0,
	0x02,0xf9,0xc2,0xa8,
	0x02,0xfa,0xc2,0xb7,
	0x02,0xfb,0xc2,0xb9,
	0x02,0xfc,0xc2,0xb3,
	0x02,0xfd,0xc2,0xb2,
	0x03,0xfe,0xe2,0x96,0xa0,
	0x02,0xff,0xc2,0xa0,
	0x02,0x27,0x5c,0x27,     /* ' escape to \' */
	0x02,0x5c,0x5c,0x5c      /* \ escape to \\ */
};
void sql2cob(char * data, char * val, int offset, struct COLUMN *col) {
	int pos;
	char * pch;
	if(col->type == _VARCHAR) {
		strncpy(data+offset,val,strlen(val));
		if(col->length > strlen(val))
			memset(data+offset+strlen(val), ' ', col->length-strlen(val));
	} else {
		memset(data+offset, '0', col->length);
		pch = strchr(val, '.');
		if(pch == NULL) {
			strncpy(data+offset+(col->length-strlen(val)),val,strlen(val));
		}
	}
}
char * cob2sql(char *string, struct COLUMN *col) {
	char *original;
	int j, k, p, l;
	if (col->type == _VARCHAR) {     /* string */
	    original = string + col->length;
		p = col->length;
		while(*--original == ' ') p--;   /* trimmed string */
		l = p+1;
		
		while(p!=0) {       /* cp857 to utf8 and escape chars for mysql */
			j = 0;
			while(j<sizeof(cp857ToUtf8)) {
				if(*original == cp857ToUtf8[j+1]) {
					memmove(original+((int)cp857ToUtf8[j]-1), original, l-p);
					for(k = 0; k<cp857ToUtf8[j]; k++)
						*(original+k) = cp857ToUtf8[j+2+k];
					l+=cp857ToUtf8[j]-1;
					break;
				}
				j+=cp857ToUtf8[j]+2;
			}
			--p;
			--original;
		}
		memmove(string+1,string, l);
		string[0] = '\'';
		string[l++] = '\'';
		string[l] = '\0';
	} else { 			/*integer or decimal */
	    original = string;
		for(j=0; j<col->length; j++) /* cobol bug zeros comes blanks */
			*(original+j) = *(original+j) == ' ' ? '0' : *(original+j);
		
		k = 0;
		while(k<col->length-col->scale-1 && *(original+k) == '0') 
			k++;
		memmove(original, original+k, col->length - k);
		k = col->length - k;
		string[k] = '\0';
		if(col->scale > 0) { /*set scale */
			memmove(original+(k-col->scale)+1, original+(k-col->scale), col->scale);
			*(original+(k-col->scale)) = '.';
			*(original+(k+1)) = '\0';
		}
			
		
	}
	return string;
}